/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: mapdata.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class Gbid extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        group?: number;
        type?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("group" in data && data.group != undefined) {
                this.group = data.group;
            }
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
        }
    }
    get group() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set group(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set type(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        group?: number;
        type?: number;
    }): Gbid {
        const message = new Gbid({});
        if (data.group != null) {
            message.group = data.group;
        }
        if (data.type != null) {
            message.type = data.type;
        }
        return message;
    }
    toObject() {
        const data: {
            group?: number;
            type?: number;
        } = {};
        if (this.group != null) {
            data.group = this.group;
        }
        if (this.type != null) {
            data.type = this.type;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.group != 0)
            writer.writeInt32(1, this.group);
        if (this.type != 0)
            writer.writeInt32(2, this.type);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Gbid {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Gbid();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.group = reader.readInt32();
                    break;
                case 2:
                    message.type = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Gbid {
        return Gbid.deserialize(bytes);
    }
}
export class ExtraMarkerData extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2], [3], [4]];
    constructor(data?: any[] | ({} & (({
        gizmoType?: number;
    }) | ({
        markerType?: number;
    }) | ({
        spawnLoc?: Gbid;
    }) | ({
        bounds?: AABB;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("gizmoType" in data && data.gizmoType != undefined) {
                this.gizmoType = data.gizmoType;
            }
            if ("markerType" in data && data.markerType != undefined) {
                this.markerType = data.markerType;
            }
            if ("spawnLoc" in data && data.spawnLoc != undefined) {
                this.spawnLoc = data.spawnLoc;
            }
            if ("bounds" in data && data.bounds != undefined) {
                this.bounds = data.bounds;
            }
        }
    }
    get gizmoType() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set gizmoType(value: number) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_gizmoType() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get markerType() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set markerType(value: number) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_markerType() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get spawnLoc() {
        return pb_1.Message.getWrapperField(this, Gbid, 3) as Gbid;
    }
    set spawnLoc(value: Gbid) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[2], value);
    }
    get has_spawnLoc() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get bounds() {
        return pb_1.Message.getWrapperField(this, AABB, 4) as AABB;
    }
    set bounds(value: AABB) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[3], value);
    }
    get has_bounds() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get _gizmoType() {
        const cases: {
            [index: number]: "none" | "gizmoType";
        } = {
            0: "none",
            1: "gizmoType"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _markerType() {
        const cases: {
            [index: number]: "none" | "markerType";
        } = {
            0: "none",
            2: "markerType"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    get _spawnLoc() {
        const cases: {
            [index: number]: "none" | "spawnLoc";
        } = {
            0: "none",
            3: "spawnLoc"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    get _bounds() {
        const cases: {
            [index: number]: "none" | "bounds";
        } = {
            0: "none",
            4: "bounds"
        };
        return cases[pb_1.Message.computeOneofCase(this, [4])];
    }
    static fromObject(data: {
        gizmoType?: number;
        markerType?: number;
        spawnLoc?: ReturnType<typeof Gbid.prototype.toObject>;
        bounds?: ReturnType<typeof AABB.prototype.toObject>;
    }): ExtraMarkerData {
        const message = new ExtraMarkerData({});
        if (data.gizmoType != null) {
            message.gizmoType = data.gizmoType;
        }
        if (data.markerType != null) {
            message.markerType = data.markerType;
        }
        if (data.spawnLoc != null) {
            message.spawnLoc = Gbid.fromObject(data.spawnLoc);
        }
        if (data.bounds != null) {
            message.bounds = AABB.fromObject(data.bounds);
        }
        return message;
    }
    toObject() {
        const data: {
            gizmoType?: number;
            markerType?: number;
            spawnLoc?: ReturnType<typeof Gbid.prototype.toObject>;
            bounds?: ReturnType<typeof AABB.prototype.toObject>;
        } = {};
        if (this.gizmoType != null) {
            data.gizmoType = this.gizmoType;
        }
        if (this.markerType != null) {
            data.markerType = this.markerType;
        }
        if (this.spawnLoc != null) {
            data.spawnLoc = this.spawnLoc.toObject();
        }
        if (this.bounds != null) {
            data.bounds = this.bounds.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_gizmoType)
            writer.writeInt32(1, this.gizmoType);
        if (this.has_markerType)
            writer.writeInt32(2, this.markerType);
        if (this.has_spawnLoc)
            writer.writeMessage(3, this.spawnLoc, () => this.spawnLoc.serialize(writer));
        if (this.has_bounds)
            writer.writeMessage(4, this.bounds, () => this.bounds.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExtraMarkerData {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ExtraMarkerData();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.gizmoType = reader.readInt32();
                    break;
                case 2:
                    message.markerType = reader.readInt32();
                    break;
                case 3:
                    reader.readMessage(message.spawnLoc, () => message.spawnLoc = Gbid.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.bounds, () => message.bounds = AABB.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ExtraMarkerData {
        return ExtraMarkerData.deserialize(bytes);
    }
}
export class MarkerData extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        refSnoGroup?: number;
        refSno?: number;
        sourceSno?: number;
        dataSnos?: number[];
        position?: Point3d;
        extra?: ExtraMarkerData;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("refSnoGroup" in data && data.refSnoGroup != undefined) {
                this.refSnoGroup = data.refSnoGroup;
            }
            if ("refSno" in data && data.refSno != undefined) {
                this.refSno = data.refSno;
            }
            if ("sourceSno" in data && data.sourceSno != undefined) {
                this.sourceSno = data.sourceSno;
            }
            if ("dataSnos" in data && data.dataSnos != undefined) {
                this.dataSnos = data.dataSnos;
            }
            if ("position" in data && data.position != undefined) {
                this.position = data.position;
            }
            if ("extra" in data && data.extra != undefined) {
                this.extra = data.extra;
            }
        }
    }
    get refSnoGroup() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set refSnoGroup(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get refSno() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set refSno(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get sourceSno() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set sourceSno(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get dataSnos() {
        return pb_1.Message.getFieldWithDefault(this, 4, []) as number[];
    }
    set dataSnos(value: number[]) {
        pb_1.Message.setField(this, 4, value);
    }
    get position() {
        return pb_1.Message.getWrapperField(this, Point3d, 5) as Point3d;
    }
    set position(value: Point3d) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_position() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get extra() {
        return pb_1.Message.getWrapperField(this, ExtraMarkerData, 9) as ExtraMarkerData;
    }
    set extra(value: ExtraMarkerData) {
        pb_1.Message.setWrapperField(this, 9, value);
    }
    get has_extra() {
        return pb_1.Message.getField(this, 9) != null;
    }
    static fromObject(data: {
        refSnoGroup?: number;
        refSno?: number;
        sourceSno?: number;
        dataSnos?: number[];
        position?: ReturnType<typeof Point3d.prototype.toObject>;
        extra?: ReturnType<typeof ExtraMarkerData.prototype.toObject>;
    }): MarkerData {
        const message = new MarkerData({});
        if (data.refSnoGroup != null) {
            message.refSnoGroup = data.refSnoGroup;
        }
        if (data.refSno != null) {
            message.refSno = data.refSno;
        }
        if (data.sourceSno != null) {
            message.sourceSno = data.sourceSno;
        }
        if (data.dataSnos != null) {
            message.dataSnos = data.dataSnos;
        }
        if (data.position != null) {
            message.position = Point3d.fromObject(data.position);
        }
        if (data.extra != null) {
            message.extra = ExtraMarkerData.fromObject(data.extra);
        }
        return message;
    }
    toObject() {
        const data: {
            refSnoGroup?: number;
            refSno?: number;
            sourceSno?: number;
            dataSnos?: number[];
            position?: ReturnType<typeof Point3d.prototype.toObject>;
            extra?: ReturnType<typeof ExtraMarkerData.prototype.toObject>;
        } = {};
        if (this.refSnoGroup != null) {
            data.refSnoGroup = this.refSnoGroup;
        }
        if (this.refSno != null) {
            data.refSno = this.refSno;
        }
        if (this.sourceSno != null) {
            data.sourceSno = this.sourceSno;
        }
        if (this.dataSnos != null) {
            data.dataSnos = this.dataSnos;
        }
        if (this.position != null) {
            data.position = this.position.toObject();
        }
        if (this.extra != null) {
            data.extra = this.extra.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.refSnoGroup != 0)
            writer.writeInt32(1, this.refSnoGroup);
        if (this.refSno != 0)
            writer.writeInt32(2, this.refSno);
        if (this.sourceSno != 0)
            writer.writeInt32(3, this.sourceSno);
        if (this.dataSnos.length)
            writer.writePackedInt32(4, this.dataSnos);
        if (this.has_position)
            writer.writeMessage(5, this.position, () => this.position.serialize(writer));
        if (this.has_extra)
            writer.writeMessage(9, this.extra, () => this.extra.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MarkerData {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MarkerData();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.refSnoGroup = reader.readInt32();
                    break;
                case 2:
                    message.refSno = reader.readInt32();
                    break;
                case 3:
                    message.sourceSno = reader.readInt32();
                    break;
                case 4:
                    message.dataSnos = reader.readPackedInt32();
                    break;
                case 5:
                    reader.readMessage(message.position, () => message.position = Point3d.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.extra, () => message.extra = ExtraMarkerData.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MarkerData {
        return MarkerData.deserialize(bytes);
    }
}
export class Point2d extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        x?: number;
        y?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("x" in data && data.x != undefined) {
                this.x = data.x;
            }
            if ("y" in data && data.y != undefined) {
                this.y = data.y;
            }
        }
    }
    get x() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set x(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get y() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set y(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        x?: number;
        y?: number;
    }): Point2d {
        const message = new Point2d({});
        if (data.x != null) {
            message.x = data.x;
        }
        if (data.y != null) {
            message.y = data.y;
        }
        return message;
    }
    toObject() {
        const data: {
            x?: number;
            y?: number;
        } = {};
        if (this.x != null) {
            data.x = this.x;
        }
        if (this.y != null) {
            data.y = this.y;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.x != 0)
            writer.writeFloat(1, this.x);
        if (this.y != 0)
            writer.writeFloat(2, this.y);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point2d {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point2d();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.x = reader.readFloat();
                    break;
                case 2:
                    message.y = reader.readFloat();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Point2d {
        return Point2d.deserialize(bytes);
    }
}
export class Point3d extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        x?: number;
        y?: number;
        z?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("x" in data && data.x != undefined) {
                this.x = data.x;
            }
            if ("y" in data && data.y != undefined) {
                this.y = data.y;
            }
            if ("z" in data && data.z != undefined) {
                this.z = data.z;
            }
        }
    }
    get x() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set x(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get y() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set y(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get z() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set z(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        x?: number;
        y?: number;
        z?: number;
    }): Point3d {
        const message = new Point3d({});
        if (data.x != null) {
            message.x = data.x;
        }
        if (data.y != null) {
            message.y = data.y;
        }
        if (data.z != null) {
            message.z = data.z;
        }
        return message;
    }
    toObject() {
        const data: {
            x?: number;
            y?: number;
            z?: number;
        } = {};
        if (this.x != null) {
            data.x = this.x;
        }
        if (this.y != null) {
            data.y = this.y;
        }
        if (this.z != null) {
            data.z = this.z;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.x != 0)
            writer.writeFloat(1, this.x);
        if (this.y != 0)
            writer.writeFloat(2, this.y);
        if (this.z != 0)
            writer.writeFloat(3, this.z);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point3d {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point3d();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.x = reader.readFloat();
                    break;
                case 2:
                    message.y = reader.readFloat();
                    break;
                case 3:
                    message.z = reader.readFloat();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Point3d {
        return Point3d.deserialize(bytes);
    }
}
export class Bounds extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        x?: number;
        y?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("x" in data && data.x != undefined) {
                this.x = data.x;
            }
            if ("y" in data && data.y != undefined) {
                this.y = data.y;
            }
        }
    }
    get x() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set x(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get y() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set y(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        x?: number;
        y?: number;
    }): Bounds {
        const message = new Bounds({});
        if (data.x != null) {
            message.x = data.x;
        }
        if (data.y != null) {
            message.y = data.y;
        }
        return message;
    }
    toObject() {
        const data: {
            x?: number;
            y?: number;
        } = {};
        if (this.x != null) {
            data.x = this.x;
        }
        if (this.y != null) {
            data.y = this.y;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.x != 0)
            writer.writeInt32(1, this.x);
        if (this.y != 0)
            writer.writeInt32(2, this.y);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Bounds {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Bounds();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.x = reader.readInt32();
                    break;
                case 2:
                    message.y = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Bounds {
        return Bounds.deserialize(bytes);
    }
}
export class AABB extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        offset?: Point3d;
        ext?: Point3d;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("offset" in data && data.offset != undefined) {
                this.offset = data.offset;
            }
            if ("ext" in data && data.ext != undefined) {
                this.ext = data.ext;
            }
        }
    }
    get offset() {
        return pb_1.Message.getWrapperField(this, Point3d, 1) as Point3d;
    }
    set offset(value: Point3d) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_offset() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get ext() {
        return pb_1.Message.getWrapperField(this, Point3d, 2) as Point3d;
    }
    set ext(value: Point3d) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_ext() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        offset?: ReturnType<typeof Point3d.prototype.toObject>;
        ext?: ReturnType<typeof Point3d.prototype.toObject>;
    }): AABB {
        const message = new AABB({});
        if (data.offset != null) {
            message.offset = Point3d.fromObject(data.offset);
        }
        if (data.ext != null) {
            message.ext = Point3d.fromObject(data.ext);
        }
        return message;
    }
    toObject() {
        const data: {
            offset?: ReturnType<typeof Point3d.prototype.toObject>;
            ext?: ReturnType<typeof Point3d.prototype.toObject>;
        } = {};
        if (this.offset != null) {
            data.offset = this.offset.toObject();
        }
        if (this.ext != null) {
            data.ext = this.ext.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_offset)
            writer.writeMessage(1, this.offset, () => this.offset.serialize(writer));
        if (this.has_ext)
            writer.writeMessage(2, this.ext, () => this.ext.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AABB {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AABB();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.offset, () => message.offset = Point3d.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.ext, () => message.ext = Point3d.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AABB {
        return AABB.deserialize(bytes);
    }
}
export class Polygon extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        vertices?: Point2d[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("vertices" in data && data.vertices != undefined) {
                this.vertices = data.vertices;
            }
        }
    }
    get vertices() {
        return pb_1.Message.getRepeatedWrapperField(this, Point2d, 1) as Point2d[];
    }
    set vertices(value: Point2d[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        vertices?: ReturnType<typeof Point2d.prototype.toObject>[];
    }): Polygon {
        const message = new Polygon({});
        if (data.vertices != null) {
            message.vertices = data.vertices.map(item => Point2d.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            vertices?: ReturnType<typeof Point2d.prototype.toObject>[];
        } = {};
        if (this.vertices != null) {
            data.vertices = this.vertices.map((item: Point2d) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.vertices.length)
            writer.writeRepeatedMessage(1, this.vertices, (item: Point2d) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Polygon {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Polygon();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.vertices, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Point2d.deserialize(reader), Point2d));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Polygon {
        return Polygon.deserialize(bytes);
    }
}
export class MapData extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        gridSize?: number;
        bounds?: Bounds;
        zoneArtScale?: number;
        zoneArtCenter?: Point2d;
        maxNativeZoom?: number;
        markers?: MarkerData[];
        polygons?: Polygon[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 7], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("gridSize" in data && data.gridSize != undefined) {
                this.gridSize = data.gridSize;
            }
            if ("bounds" in data && data.bounds != undefined) {
                this.bounds = data.bounds;
            }
            if ("zoneArtScale" in data && data.zoneArtScale != undefined) {
                this.zoneArtScale = data.zoneArtScale;
            }
            if ("zoneArtCenter" in data && data.zoneArtCenter != undefined) {
                this.zoneArtCenter = data.zoneArtCenter;
            }
            if ("maxNativeZoom" in data && data.maxNativeZoom != undefined) {
                this.maxNativeZoom = data.maxNativeZoom;
            }
            if ("markers" in data && data.markers != undefined) {
                this.markers = data.markers;
            }
            if ("polygons" in data && data.polygons != undefined) {
                this.polygons = data.polygons;
            }
        }
    }
    get gridSize() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set gridSize(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get bounds() {
        return pb_1.Message.getWrapperField(this, Bounds, 2) as Bounds;
    }
    set bounds(value: Bounds) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_bounds() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get zoneArtScale() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set zoneArtScale(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get zoneArtCenter() {
        return pb_1.Message.getWrapperField(this, Point2d, 4) as Point2d;
    }
    set zoneArtCenter(value: Point2d) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_zoneArtCenter() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get maxNativeZoom() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set maxNativeZoom(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get markers() {
        return pb_1.Message.getRepeatedWrapperField(this, MarkerData, 6) as MarkerData[];
    }
    set markers(value: MarkerData[]) {
        pb_1.Message.setRepeatedWrapperField(this, 6, value);
    }
    get polygons() {
        return pb_1.Message.getRepeatedWrapperField(this, Polygon, 7) as Polygon[];
    }
    set polygons(value: Polygon[]) {
        pb_1.Message.setRepeatedWrapperField(this, 7, value);
    }
    static fromObject(data: {
        gridSize?: number;
        bounds?: ReturnType<typeof Bounds.prototype.toObject>;
        zoneArtScale?: number;
        zoneArtCenter?: ReturnType<typeof Point2d.prototype.toObject>;
        maxNativeZoom?: number;
        markers?: ReturnType<typeof MarkerData.prototype.toObject>[];
        polygons?: ReturnType<typeof Polygon.prototype.toObject>[];
    }): MapData {
        const message = new MapData({});
        if (data.gridSize != null) {
            message.gridSize = data.gridSize;
        }
        if (data.bounds != null) {
            message.bounds = Bounds.fromObject(data.bounds);
        }
        if (data.zoneArtScale != null) {
            message.zoneArtScale = data.zoneArtScale;
        }
        if (data.zoneArtCenter != null) {
            message.zoneArtCenter = Point2d.fromObject(data.zoneArtCenter);
        }
        if (data.maxNativeZoom != null) {
            message.maxNativeZoom = data.maxNativeZoom;
        }
        if (data.markers != null) {
            message.markers = data.markers.map(item => MarkerData.fromObject(item));
        }
        if (data.polygons != null) {
            message.polygons = data.polygons.map(item => Polygon.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            gridSize?: number;
            bounds?: ReturnType<typeof Bounds.prototype.toObject>;
            zoneArtScale?: number;
            zoneArtCenter?: ReturnType<typeof Point2d.prototype.toObject>;
            maxNativeZoom?: number;
            markers?: ReturnType<typeof MarkerData.prototype.toObject>[];
            polygons?: ReturnType<typeof Polygon.prototype.toObject>[];
        } = {};
        if (this.gridSize != null) {
            data.gridSize = this.gridSize;
        }
        if (this.bounds != null) {
            data.bounds = this.bounds.toObject();
        }
        if (this.zoneArtScale != null) {
            data.zoneArtScale = this.zoneArtScale;
        }
        if (this.zoneArtCenter != null) {
            data.zoneArtCenter = this.zoneArtCenter.toObject();
        }
        if (this.maxNativeZoom != null) {
            data.maxNativeZoom = this.maxNativeZoom;
        }
        if (this.markers != null) {
            data.markers = this.markers.map((item: MarkerData) => item.toObject());
        }
        if (this.polygons != null) {
            data.polygons = this.polygons.map((item: Polygon) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.gridSize != 0)
            writer.writeFloat(1, this.gridSize);
        if (this.has_bounds)
            writer.writeMessage(2, this.bounds, () => this.bounds.serialize(writer));
        if (this.zoneArtScale != 0)
            writer.writeFloat(3, this.zoneArtScale);
        if (this.has_zoneArtCenter)
            writer.writeMessage(4, this.zoneArtCenter, () => this.zoneArtCenter.serialize(writer));
        if (this.maxNativeZoom != 0)
            writer.writeUint32(5, this.maxNativeZoom);
        if (this.markers.length)
            writer.writeRepeatedMessage(6, this.markers, (item: MarkerData) => item.serialize(writer));
        if (this.polygons.length)
            writer.writeRepeatedMessage(7, this.polygons, (item: Polygon) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapData {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapData();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.gridSize = reader.readFloat();
                    break;
                case 2:
                    reader.readMessage(message.bounds, () => message.bounds = Bounds.deserialize(reader));
                    break;
                case 3:
                    message.zoneArtScale = reader.readFloat();
                    break;
                case 4:
                    reader.readMessage(message.zoneArtCenter, () => message.zoneArtCenter = Point2d.deserialize(reader));
                    break;
                case 5:
                    message.maxNativeZoom = reader.readUint32();
                    break;
                case 6:
                    reader.readMessage(message.markers, () => pb_1.Message.addToRepeatedWrapperField(message, 6, MarkerData.deserialize(reader), MarkerData));
                    break;
                case 7:
                    reader.readMessage(message.polygons, () => pb_1.Message.addToRepeatedWrapperField(message, 7, Polygon.deserialize(reader), Polygon));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MapData {
        return MapData.deserialize(bytes);
    }
}
